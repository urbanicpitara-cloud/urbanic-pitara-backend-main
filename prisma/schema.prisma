generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * * ENUMS **
 */
enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELED
  REFUNDED
}

enum PaymentStatus {
  INITIATED
  PAID
  FAILED
  REFUNDED
  NONE
}

enum DiscountType {
  PERCENTAGE
  FIXED
}

enum PaymentMethod {
  COD        // Cash on delivery
  STRIPE
  RAZORPAY
  PAYPAL
  // add more providers as needed
}


/**
 * * MODELS **
 */

model Collection {
  id              String  @id @default(cuid())
  handle          String  @unique
  title           String
  description     String?
  descriptionHtml String?
  imageUrl        String?
  imageAlt        String?

  products Product[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deletedAt DateTime? // soft-delete

  @@index([handle])
}

model Product {
  id              String     @id @default(cuid())
  handle          String     @unique
  title           String
  vendor          String?
  description     String?
  descriptionHtml String?
  collection      Collection? @relation(fields: [collectionId], references: [id])
  collectionId    String?

  tags ProductTag[]

  featuredImageUrl String?
  featuredImageAlt String?

  images        ProductImage[]
  options       ProductOption[]
  variants      ProductVariant[]
  reviews       Review[]
  wishlistItems WishlistItem[]

  metafields  Json?
  published   Boolean   @default(true)
  publishedAt DateTime?
  deletedAt   DateTime? // soft-delete

  cartLines  CartLine[]  @relation("CartLine_Product")
  orderItems OrderItem[] @relation("OrderItem_Product")

  minPriceAmount   Decimal @db.Decimal(10, 2)
  minPriceCurrency String
  maxPriceAmount   Decimal @db.Decimal(10, 2)
  maxPriceCurrency String

  compareMinAmount   Decimal? @db.Decimal(10, 2)
  compareMinCurrency String?
  compareMaxAmount   Decimal? @db.Decimal(10, 2)
  compareMaxCurrency String?

  // SEO
  metaTitle       String?
  metaDescription String?
  metaKeywords    String?

  // Aggregates
  averageRating Float? @default(0)
  reviewCount   Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([handle])
  @@index([collectionId])
  @@index([published])
}

model ProductImage {
  id        String  @id @default(cuid())
  url       String
  altText   String?
  product   Product @relation(fields: [productId], references: [id])
  productId String
}

model ProductOption {
  id        String               @id @default(cuid())
  name      String
  product   Product              @relation(fields: [productId], references: [id])
  productId String
  values    ProductOptionValue[]
}

model ProductOptionValue {
  id       String        @id @default(cuid())
  name     String
  color    String?
  option   ProductOption @relation(fields: [optionId], references: [id])
  optionId String
}

model ProductVariant {
  id               String   @id @default(cuid())
  product          Product  @relation(fields: [productId], references: [id])
  productId        String
  availableForSale Boolean  @default(true)
  priceAmount      Decimal  @db.Decimal(10, 2)
  priceCurrency    String
  compareAmount    Decimal? @db.Decimal(10, 2)
  compareCurrency  String?

  sku               String?
  barcode           String?
  inventoryQuantity Int     @default(0)
  lowStockThreshold Int?    @default(5)
  weightInGrams     Int?

  selectedOptions Json

  cartLines  CartLine[]  @relation("CartLine_Variant")
  orderItems OrderItem[] @relation("OrderItem_Variant")

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([sku])
}

model Menu {
  id     String     @id @default(cuid())
  handle String     @unique
  items  MenuItem[]
}

model MenuItem {
  id       String     @id @default(cuid())
  title    String
  url      String
  menu     Menu       @relation(fields: [menuId], references: [id])
  menuId   String
  parent   MenuItem?  @relation("MenuItemToChildren", fields: [parentId], references: [id])
  parentId String?
  children MenuItem[] @relation("MenuItemToChildren")
}

model User {
  id               String     @id @default(cuid())
  email            String     @unique
  passwordHash     String
  firstName        String?
  lastName         String?
  isAdmin          Boolean    @default(false)
  phone            String?
  addresses        Address[]
  orders           Order[]
  carts            Cart[]
  wishlists        Wishlist[]
  reviews          Review[]
  resetToken       String?
  resetTokenExpiry DateTime?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @default(now()) @updatedAt
  deletedAt        DateTime? // soft-delete

  @@index([email])
}

model Address {
  id          String  @id @default(cuid())
  user        User    @relation(fields: [userId], references: [id])
  userId      String
  firstName   String
  lastName    String
  address1    String
  address2    String?
  city        String
  province    String?
  zip         String?
  country     String
  countryCode String?
  phone       String?
  isDefault   Boolean @default(false)

  // back-relations for orders
  ordersAsShipping Order[] @relation("Order_ShippingAddress")
  ordersAsBilling  Order[] @relation("Order_BillingAddress")

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

/**
 * * CART **
 */
model Cart {
  id            String     @id @default(cuid())
  user          User?      @relation(fields: [userId], references: [id])
  userId        String?
  totalQuantity Int        @default(0)
  lines         CartLine[]
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @default(now()) @updatedAt
}

model CartLine {
  id            String          @id @default(cuid())
  cart          Cart            @relation(fields: [cartId], references: [id])
  cartId        String
  product       Product         @relation("CartLine_Product", fields: [productId], references: [id])
  productId     String
  variant       ProductVariant? @relation("CartLine_Variant", fields: [variantId], references: [id])
  variantId     String?
  quantity      Int             @default(1)
  priceAmount   Decimal         @db.Decimal(10, 2)
  priceCurrency String
}

/**
 * * ORDERS **
 */
// model Order {
//   id     String @id @default(cuid())
//   user   User   @relation(fields: [userId], references: [id])
//   userId String

//   // Legacy - keep for now (string) so existing app doesn't break
//   status        OrderStatus? @default(PENDING)
//   totalAmount   String
//   totalCurrency String

//   // NEW recommended fields (non-breaking). Backfill these, then switch code to use them.
//   statusEnum         OrderStatus? @default(PENDING)
//   totalAmountDecimal Decimal?     @db.Decimal(10, 2)
//   totalCurrencyCode  String?

//   orderNumber       String?
//   paymentMethod     String?
//   paymentId         String? // link to Payment model
//   payment           Payment?
//   placedAt          DateTime    @default(now())
//   items             OrderItem[]
//   shippingAddressId String?
//   shippingAddress   Address?    @relation("Order_ShippingAddress", fields: [shippingAddressId], references: [id])
//   billingAddressId  String?
//   billingAddress    Address?    @relation("Order_BillingAddress", fields: [billingAddressId], references: [id])
//   cancelReason      String?

//   // discount 
//   discountAmount    Decimal?  @default(0)
//   appliedDiscountId String?
//   appliedDiscount   Discount? @relation("OrderDiscount", fields: [appliedDiscountId], references: [id])
//   // ðŸ‘† Explicit relation name added here

//   // tracking/admin
//   trackingNumber  String?
//   trackingCompany String?
//   adminNotes      String?

//   createdAt DateTime @default(now())
//   updatedAt DateTime @default(now()) @updatedAt

//   @@index([userId])
//   @@index([status])
//   @@index([placedAt])
// }

model Order {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String

  //   // Legacy - keep for now (string) so existing app doesn't break
  status        OrderStatus? @default(PENDING)
  totalAmount   String
  totalCurrency String

  orderNumber       String?
  paymentId         String? // link to Payment model
  payment           Payment?

  placedAt          DateTime    @default(now())
  items             OrderItem[]
  shippingAddressId String?
  shippingAddress   Address?    @relation("Order_ShippingAddress", fields: [shippingAddressId], references: [id])
  billingAddressId  String?
  billingAddress    Address?    @relation("Order_BillingAddress", fields: [billingAddressId], references: [id])
  cancelReason      String?

  discountAmount    Decimal?  @default(0)
  appliedDiscountId String?
  appliedDiscount   Discount? @relation("OrderDiscount", fields: [appliedDiscountId], references: [id])

  trackingNumber  String?
  trackingCompany String?
  adminNotes      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([userId])
  @@index([status])
  @@index([placedAt])
}


/**
 * * ORDER ITEMS **
 */
model OrderItem {
  id            String          @id @default(cuid())
  order         Order           @relation(fields: [orderId], references: [id])
  orderId       String
  product       Product         @relation("OrderItem_Product", fields: [productId], references: [id])
  productId     String
  variant       ProductVariant? @relation("OrderItem_Variant", fields: [variantId], references: [id])
  variantId     String?
  quantity      Int
  priceAmount   Decimal         @db.Decimal(10, 2)
  priceCurrency String
}

/**
 * * TAGS **
 */
model Tag {
  id          String       @id @default(cuid())
  handle      String       @unique
  name        String       @unique
  description String?
  products    ProductTag[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @default(now()) @updatedAt
}

/**
 * * MIDDLE TABLE **
 */
model ProductTag {
  product   Product  @relation(fields: [productId], references: [id])
  productId String
  tag       Tag      @relation(fields: [tagId], references: [id])
  tagId     String
  createdAt DateTime @default(now())

  @@id([productId, tagId])
  @@index([tagId])
  @@index([productId])
}

/**
 * * REVIEWS **
 */
model Review {
  id        String   @id @default(cuid())
  rating    Int
  title     String?
  comment   String?
  product   Product  @relation(fields: [productId], references: [id])
  productId String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  approved  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([productId])
  @@index([userId])
}

/**
 * * WISHLIST **
 */
model Wishlist {
  id        String         @id @default(cuid())
  user      User           @relation(fields: [userId], references: [id])
  userId    String
  items     WishlistItem[]
  createdAt DateTime       @default(now())
}

model WishlistItem {
  id         String   @id @default(cuid())
  wishlist   Wishlist @relation(fields: [wishlistId], references: [id])
  wishlistId String
  product    Product  @relation(fields: [productId], references: [id])
  productId  String
  createdAt  DateTime @default(now())

  @@index([productId])
}

/**
 * * DISCOUNTS / COUPONS **
 */
model Discount {
  id             String       @id @default(cuid())
  code           String       @unique
  description    String?
  type           DiscountType
  value          Decimal      @db.Decimal(10, 2)
  minOrderAmount Decimal?     @db.Decimal(10, 2)
  active         Boolean      @default(true)
  startsAt       DateTime?
  endsAt         DateTime?
  usageLimit     Int? // null = unlimited
  orders         Order[]      @relation("OrderDiscount")
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now()) @updatedAt
}

/**
 * * PAYMENTS **
 */
// model Payment {
//   id                String   @id @default(cuid())
//   order             Order?   @relation(fields: [orderId], references: [id])
//   orderId           String?  @unique // âœ… This makes it one-to-one
//   provider          String // "razorpay", "stripe", etc.
//   providerOrderId   String?
//   providerPaymentId String?
//   amount            Decimal  @db.Decimal(10, 2)
//   currency          String
//   status            PaymentStatus @default(NONE) // "INITIATED", "PAID", "FAILED", "REFUNDED" "NONE"
//   rawResponse       Json? // store webhook payload if needed
//   createdAt         DateTime @default(now())
//   updatedAt         DateTime @default(now()) @updatedAt

//   @@index([providerPaymentId])
//   @@index([orderId])
// }

model Payment {
  id                String        @id @default(cuid())
  order             Order?        @relation(fields: [orderId], references: [id])
  orderId           String?       @unique
  method            PaymentMethod // new enum field
  provider          String?       // optional, e.g., "stripe", "razorpay"
  providerOrderId   String?
  providerPaymentId String?
  amount            Decimal       @db.Decimal(10, 2)
  currency          String
  status            PaymentStatus @default(NONE) // "INITIATED", "PAID", "FAILED", "REFUNDED" "NONE"
  rawResponse       Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @default(now()) @updatedAt

  @@index([providerPaymentId])
  @@index([orderId])
}


/**
 * * PAGES / CMS **
 */
model Page {
  id              String   @id @default(cuid())
  slug            String   @unique
  title           String
  body            String?
  metaTitle       String?
  metaDescription String?
  published       Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now()) @updatedAt
}

/**
 * * SIMPLE ANALYTICS (OPTIONAL) **
 */
model EventLog {
  id        String   @id @default(cuid())
  type      String
  payload   Json?
  createdAt DateTime @default(now())
}
